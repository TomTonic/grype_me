---
name: Move Action Tags

'on':
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      source-tag:
        description: >-
          Source tag to use for moving tags (for example `v1.0.0` or
          `v1.2.3-release`). Leave empty to use the triggering tag.
        required: false
        default: ''

permissions:
  contents: write

jobs:
  move-tags:
    name: Update moving tags (vX, vX.Y, vX.Y.Z)
    runs-on: ubuntu-latest
    steps:
      - name: Update moving tags
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          github-token: ${{ secrets.REPO_TAG_UPDATE_TOKEN }}
          script: |
            // NOTE: workflow_dispatch inputs are available via context.payload.inputs (not core.getInput),
            // since this script runs inside actions/github-script (not a composite action).
            const dispatchInputs = context.payload?.inputs || {};
            const inputTagRaw = String(dispatchInputs['source-tag'] || '').trim();

            // Determine source tag:
            // - On tag push: context.ref is refs/tags/<tag>
            // - On workflow_dispatch: require input
            let rawTagName = '';
            if (inputTagRaw) {
              rawTagName = inputTagRaw;
            } else if (String(context.ref || '').startsWith('refs/tags/')) {
              rawTagName = context.ref.replace('refs/tags/', '');
            } else {
            const errMsg = [
              "No source tag provided.",
              "On manual runs, set the workflow input 'source-tag'",
              `(e.g. v1.1.0-release). Current ref: ${context.ref}`,
            ].join(' ');
            throw new Error(errMsg);
            }

            // Accept values like refs/tags/v1.2.3 too.
            rawTagName = rawTagName.replace(/^refs\/tags\//, '');

            core.info(`Source tag: ${rawTagName}`);

            // Allow tags with suffixes, e.g.
            // - v1.2.3-release
            // - v1.2.3_grype-0.107.0_db-2026-01-31T06-20-12Z
            // We extract the leading semver-ish portion (vX, vX.Y, vX.Y.Z) and use that for tag movement.
            const semverMatch = rawTagName.match(/^(v\d+(?:\.\d+){0,2})(?:$|[-_].*)/);
            if (!semverMatch) {
              core.info(`Skipping non-semver tag: ${rawTagName}`);
              return;
            }

            const normalizedTagName = semverMatch[1];

            const version = normalizedTagName.replace(/^v/, '');
            const parts = version.split('.');
            const major = `v${parts[0]}`;
            const minor = parts.length >= 2 ? `v${parts[0]}.${parts[1]}` : null;
            const full = normalizedTagName;

            core.info(`Normalized semver: ${full}`);
            core.info(`Will upsert tags: ${[major, minor, full].filter(Boolean).join(', ')}`);

            const { data: ref } = await github.rest.git.getRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: `tags/${rawTagName}`,
            });
            const sha = ref.object.sha;
            core.info(`Source SHA: ${sha}`);

            async function upsertTag(tag) {
              const refName = `refs/tags/${tag}`;
              try {
                await github.rest.git.updateRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `tags/${tag}`,
                  sha,
                  force: true,
                });
                core.info(`Updated ${refName} -> ${sha}`);
              } catch (error) {
                // GitHub returns 422 (Reference does not exist) when attempting to update a ref that doesn't exist.
                if (error.status !== 404 && error.status !== 422) throw error;
                await github.rest.git.createRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: refName,
                  sha,
                });
                core.info(`Created ${refName} -> ${sha}`);
              }
            }

            // Update moving tags (vX, vX.Y) and also ensure the full vX.Y.Z tag exists.
            const tags = [major, minor, full].filter(Boolean);
            const seen = new Set();
            for (const tag of tags) {
              if (seen.has(tag)) continue;
              seen.add(tag);
              await upsertTag(tag);
            }

            // Verify tags now point at the expected SHA
            for (const tag of tags) {
              const { data: movedRef } = await github.rest.git.getRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: `tags/${tag}`,
              });
              core.info(`Verified refs/tags/${tag} -> ${movedRef.object.sha}`);
              if (movedRef.object.sha !== sha) {
                throw new Error(`Tag ${tag} points to ${movedRef.object.sha}, expected ${sha}`);
              }
            }
