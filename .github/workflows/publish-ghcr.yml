---
name: Publish GHCR Image

'on':
  release:
    types: [published]
  schedule:
    - cron: '0 6 * * *'
  workflow_dispatch:

permissions:
  contents: read

jobs:
  ci:
    name: Run CI
    uses: TomTonic/grype_me/.github/workflows/ci.yml@main
    permissions:
      contents: read

  grype-release:
    name: Check Grype Release
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: read
    outputs:
      grype_version: ${{ steps.check.outputs.grype_version }}
      action_version: ${{ steps.check.outputs.action_version }}
      publish: ${{ steps.check.outputs.publish }}
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@e3f713f2d8f53843e71c69a996d56f51aa9adfb9 # v2.14.1
        with:
          egress-policy: audit

      - name: Determine latest Grype release
        id: check
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          script: |
            const ownerInfo = await github.rest.users.getByUsername({
              username: context.repo.owner
            });
            const ownerType = ownerInfo.data.type || 'User';
            const release = await github.rest.repos.getLatestRelease({
              owner: 'anchore',
              repo: 'grype'
            });
            const grypeVersion = release.data.tag_name.replace(/^v/, '');
            core.info(`Latest grype release: ${grypeVersion}`);

            // Get latest action release for scheduled builds
            let actionVersion = '';
            try {
              const actionRelease = await github.rest.repos.getLatestRelease({
                owner: context.repo.owner,
                repo: context.repo.repo
              });
              actionVersion = actionRelease.data.tag_name.replace(/^v/, '');
              core.info(`Latest action release: ${actionVersion}`);
            } catch (error) {
              if (error.status === 404) {
                actionVersion = '1.0.0';
                core.info('No action release found, using default version 1.0.0');
              } else {
                throw error;
              }
            }

            const packageName = context.repo.repo;
            let versions = [];
            try {
              const listParams = {
                package_type: 'container',
                package_name: packageName,
                per_page: 100
              };
              if (ownerType === 'Organization') {
                listParams.org = context.repo.owner;
                versions = await github.paginate(
                  github.rest.packages.getAllPackageVersionsForPackageOwnedByOrg,
                  listParams
                );
              } else {
                listParams.username = context.repo.owner;
                versions = await github.paginate(
                  github.rest.packages.getAllPackageVersionsForPackageOwnedByUser,
                  listParams
                );
              }
            } catch (error) {
              if (error.status !== 404) {
                throw error;
              }
              core.info('No existing GHCR package found yet.');
            }

            // Determine which tag to check based on event
            const eventName = context.eventName;
            let targetTag;
            if (eventName === 'release') {
              const releaseTag = context.payload.release?.tag_name || '';
              targetTag = releaseTag ? `${releaseTag}-release` : '';
            } else {
              targetTag = `v${actionVersion}_grype-${grypeVersion}`;
            }

            let hasTag = false;
            if (targetTag) {
              hasTag = versions.some((version) =>
                (version.metadata?.container?.tags || []).includes(targetTag)
              );
              core.info(`GHCR tag ${targetTag} exists: ${hasTag}`);
            } else {
              core.info('No target tag determined; will publish.');
            }

            const publish = eventName === 'release' ? 'true' : (hasTag ? 'false' : 'true');

            core.setOutput('grype_version', grypeVersion);
            core.setOutput('action_version', actionVersion);
            core.setOutput('target_tag', targetTag || '');
            core.setOutput('publish', publish);

  publish:
    name: Publish to GHCR
    runs-on: ubuntu-latest
    needs: [ci, grype-release]
    if: github.event_name == 'release' || needs.grype-release.outputs.publish == 'true'
    permissions:
      contents: read
      packages: write
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@e3f713f2d8f53843e71c69a996d56f51aa9adfb9 # v2.14.1
        with:
          egress-policy: audit

      - name: Checkout code
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f # v3.12.0

      - name: Log in to GHCR
        uses: docker/login-action@c94ce9fb468520275223c153574b00df6fe4bcc9 # v3.7.0
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Prepare image tags
        id: tags
        env:
          EVENT_NAME: ${{ github.event_name }}
          RELEASE_TAG: ${{ github.event.release.tag_name }}
          GRYPE_VERSION: ${{ needs.grype-release.outputs.grype_version }}
          ACTION_VERSION: ${{ needs.grype-release.outputs.action_version }}
        run: |
          IMAGE_NAME="ghcr.io/${{ github.repository }}"
          IMAGE_NAME=$(echo "$IMAGE_NAME" | tr '[:upper:]' '[:lower:]')
          if [ "$EVENT_NAME" = "release" ]; then
            # Manual release: vX.Y.Z-release + moving tags
            VERSION="${RELEASE_TAG#v}"
            MAJOR="v${VERSION%%.*}"
            MINOR="v${VERSION%.*}"
            SPECIFIC_TAG="${IMAGE_NAME}:v${VERSION}-release"
            MOVING_TAGS="${IMAGE_NAME}:${RELEASE_TAG},${IMAGE_NAME}:${MAJOR},${IMAGE_NAME}:${MINOR},${IMAGE_NAME}:latest"
            TAGS="${SPECIFIC_TAG},${MOVING_TAGS}"
          else
            # Automatic build: vX.Y.Z_grype-A.B.C + moving tags
            VERSION="${ACTION_VERSION}"
            MAJOR="v${VERSION%%.*}"
            MINOR="v${VERSION%.*}"
            SPECIFIC_TAG="${IMAGE_NAME}:v${VERSION}_grype-${GRYPE_VERSION}"
            MOVING_TAGS="${IMAGE_NAME}:v${VERSION},${IMAGE_NAME}:${MAJOR},${IMAGE_NAME}:${MINOR},${IMAGE_NAME}:latest"
            TAGS="${SPECIFIC_TAG},${MOVING_TAGS}"
          fi
          echo "tags=$TAGS" >> "$GITHUB_OUTPUT"

      - name: Build and push image
        uses: docker/build-push-action@263435318d21b8e681c14492fe198d362a7d2c83 # v6.18.0
        with:
          context: .
          push: true
          tags: ${{ steps.tags.outputs.tags }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
