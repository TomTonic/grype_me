---
name: Publish GHCR Image

'on':
  release:
    types: [published]
  schedule:
    - cron: '53 6 * * *' # daily 06:53 UTC - after Grype DB update (approx 06:15 UTC)
  workflow_dispatch:

permissions:
  contents: read

jobs:
  lint:
    name: Lint
    uses: ./.github/workflows/_ci-lint.yml

  test:
    name: Test
    uses: ./.github/workflows/_ci-test.yml

  grype-release:
    name: Data for Tags and Publishing Decision
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: read
    outputs:
      grype_version: ${{ steps.check.outputs.grype_version }}
      action_version: ${{ steps.check.outputs.action_version }}
      db_built: ${{ steps.check.outputs.db_built }}
      publish: ${{ steps.check.outputs.publish }}
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@e3f713f2d8f53843e71c69a996d56f51aa9adfb9 # v2.14.1
        with:
          egress-policy: audit

      - name: Determine latest Grype release, DB version, action version and whether to publish
        id: check
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          script: |
            const ownerInfo = await github.rest.users.getByUsername({
              username: context.repo.owner
            });
            const ownerType = ownerInfo.data.type || 'User';
            const release = await github.rest.repos.getLatestRelease({
              owner: 'anchore',
              repo: 'grype'
            });
            const grypeVersion = release.data.tag_name.replace(/^v/, '');
            core.info(`Latest grype release: ${grypeVersion}`);

            // Fetch latest Grype DB metadata from the same default endpoint Grype uses
            // (see grype/db/v6/distribution DefaultConfig().LatestURL).
            const dbLatestUrl = 'https://grype.anchore.io/databases/v6/latest.json';
            const dbLatestResp = await fetch(dbLatestUrl);
            if (!dbLatestResp.ok) {
              throw new Error(`Failed to fetch Grype DB latest.json (${dbLatestUrl}): HTTP ${dbLatestResp.status}`);
            }

            const dbLatest = await dbLatestResp.json();
            const dbBuiltRaw = dbLatest?.built || dbLatest?.archive?.built;
            if (typeof dbBuiltRaw !== 'string' || !dbBuiltRaw.includes('T')) {
              throw new Error(`Unexpected Grype DB latest.json format: missing/invalid built field`);
            }

            // Docker/OCI tags cannot contain ':' so we need a tag-safe representation.
            // Example: 2026-01-31T06:20:12Z -> 2026-01-31T06-20-12Z
            const dbBuiltTag = dbBuiltRaw.replace(/[^A-Za-z0-9_.-]/g, '-');
            core.info(`Latest Grype DB built: ${dbBuiltRaw} (tag-safe: ${dbBuiltTag})`);

            // Get latest action release for scheduled builds
            let actionVersion = '';
            try {
              const actionRelease = await github.rest.repos.getLatestRelease({
                owner: context.repo.owner,
                repo: context.repo.repo
              });
              actionVersion = actionRelease.data.tag_name.replace(/^v/, '').replace(/-release$/, '');
              core.info(`Latest action release: ${actionVersion}`);
            } catch (error) {
              if (error.status === 404) {
                actionVersion = '1.0.0';
                core.info('No action release found, using default version 1.0.0');
              } else {
                throw error;
              }
            }

            const packageName = context.repo.repo;
            let versions = [];
            try {
              const listParams = {
                package_type: 'container',
                package_name: packageName,
                per_page: 100
              };
              if (ownerType === 'Organization') {
                listParams.org = context.repo.owner;
                versions = await github.paginate(
                  github.rest.packages.getAllPackageVersionsForPackageOwnedByOrg,
                  listParams
                );
              } else {
                listParams.username = context.repo.owner;
                versions = await github.paginate(
                  github.rest.packages.getAllPackageVersionsForPackageOwnedByUser,
                  listParams
                );
              }
            } catch (error) {
              if (error.status !== 404) {
                throw error;
              }
              core.info('No existing GHCR package found yet.');
            }

            // Determine which tag to check based on event
            const eventName = context.eventName;
            let targetTag;
            if (eventName === 'release') {
              const releaseTag = context.payload.release?.tag_name || '';
              targetTag = releaseTag ? `${releaseTag}-release` : '';
            } else {
              targetTag = `v${actionVersion}_grype-${grypeVersion}_db-${dbBuiltTag}`;
            }

            let hasTag = false;
            if (targetTag) {
              hasTag = versions.some((version) =>
                (version.metadata?.container?.tags || []).includes(targetTag)
              );
              core.info(`GHCR tag ${targetTag} exists; will NOT publish.`);
            } else {
              core.info(`No target tag ${targetTag} determined; will publish.`);
            }

            const publish = eventName === 'release' ? 'true' : (hasTag ? 'false' : 'true');

            core.setOutput('grype_version', grypeVersion);
            core.setOutput('action_version', actionVersion);
            core.setOutput('db_built', dbBuiltTag);
            core.setOutput('target_tag', targetTag || '');
            core.setOutput('publish', publish);

  publish:
    name: Publish to GHCR
    runs-on: ubuntu-latest
    needs: [lint, test, grype-release]
    if: github.event_name == 'release' || needs.grype-release.outputs.publish == 'true'
    permissions:
      contents: read
      packages: write
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@e3f713f2d8f53843e71c69a996d56f51aa9adfb9 # v2.14.1
        with:
          egress-policy: audit

      - name: Checkout code
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f # v3.12.0

      - name: Log in to GHCR
        uses: docker/login-action@c94ce9fb468520275223c153574b00df6fe4bcc9 # v3.7.0
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Prepare image tags
        id: tags
        env:
          EVENT_NAME: ${{ github.event_name }}
          RELEASE_TAG: ${{ github.event.release.tag_name }}
          GRYPE_VERSION: ${{ needs.grype-release.outputs.grype_version }}
          ACTION_VERSION: ${{ needs.grype-release.outputs.action_version }}
          DB_BUILT: ${{ needs.grype-release.outputs.db_built }}
        run: |
          IMAGE_NAME="ghcr.io/${{ github.repository }}"
          IMAGE_NAME=$(echo "$IMAGE_NAME" | tr '[:upper:]' '[:lower:]')

          if [ "$EVENT_NAME" = "release" ]; then
            # Manual release triggered by GitHub Release
            # RELEASE_TAG may be "v1.2.3" or "v1.2.3-release"
            MY_VER="${RELEASE_TAG}"
          else
            # Automatic/nightly build (schedule or workflow_dispatch)
            MY_VER="${ACTION_VERSION}"
          fi

          # Normalize to semver: MY_VER may be "v1.2.3" or "v1.2.3-release"
          MY_VER="${MY_VER#v}"                 # strip leading v
          SEMVER="${MY_VER%-release}"          # strip trailing -release if present

          MAJOR="v${SEMVER%%.*}"              # v1
          MINOR="v${SEMVER%.*}"               # v1.2
          PATCH="v${SEMVER}"                  # v1.2.3

          if [ "$EVENT_NAME" = "release" ]; then
            # Fixed tag (immutable): vX.Y.Z-release
            SPECIFIC_TAG="${IMAGE_NAME}:${PATCH}-release"
          else
            # Fixed tag (immutable): vX.Y.Z_grype-A.B.C_db-YYYY-MM-DDTHH-MM-SSZ
            SPECIFIC_TAG="${IMAGE_NAME}:${PATCH}_grype-${GRYPE_VERSION}_db-${DB_BUILT}"
          fi

          # Moving tags: vX.Y.Z, vX.Y, vX, latest
          MOVING_TAGS="${IMAGE_NAME}:${PATCH},${IMAGE_NAME}:${MINOR},${IMAGE_NAME}:${MAJOR},${IMAGE_NAME}:latest"

          TAGS="${SPECIFIC_TAG},${MOVING_TAGS}"

          echo "Generated tags: $TAGS"
          echo "tags=$TAGS" >> "$GITHUB_OUTPUT"
          echo "image_name=$IMAGE_NAME" >> "$GITHUB_OUTPUT"
          # Provide a short output containing the cachebust build-arg so later steps can reference it
          BUILD_CACHEBUST="${IMAGE_NAME}:dummy" || true
          BUILD_CACHEBUST="grype-${GRYPE_VERSION}_db-${DB_BUILT}"
          echo "build_cachebust=$BUILD_CACHEBUST" >> "$GITHUB_OUTPUT"

      - name: Build image (load for test)
        uses: docker/build-push-action@263435318d21b8e681c14492fe198d362a7d2c83 # v6.18.0
        with:
          context: .
          push: false
          load: true
          tags: ${{ steps.tags.outputs.tags }}
          build-args: |
            GRYPE_CACHEBUST=${{ steps.tags.outputs.build_cachebust }}
          cache-from: type=gha,scope=grype_me
          cache-to: type=gha,mode=max,scope=grype_me

      - name: Test built image (pre-push)
        id: grype-scan-prepush
        uses: ./.github/actions/run-grype-me-container
        with:
          image-ref: ${{ steps.tags.outputs.image_name }}:latest
          pull: 'false'
          scan: head
          output-file: grype-results-prepush.json
          variable-prefix: GRYPE_PREPUSH_
          fail-build: 'false'
          severity-cutoff: medium
          only-fixed: 'false'
          db-update: 'false'
          debug: 'false'
          outputs-file: github_output_prepush.txt

      - name: Push tested tags
        shell: bash
        env:
          TAGS: ${{ steps.tags.outputs.tags }}
        run: |
          set -euo pipefail
          IFS=',' read -ra tags <<< "$TAGS"
          for t in "${tags[@]}"; do
            echo "Pushing $t"
            docker push "$t"
          done

  verify-published:
    name: Verify Published Image
    runs-on: ubuntu-latest
    needs: [publish, grype-release]
    permissions:
      contents: read
      packages: read
    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@e3f713f2d8f53843e71c69a996d56f51aa9adfb9 # v2.14.1
        with:
          egress-policy: audit

      - name: Checkout code
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2

      - name: Wait for GHCR propagation
        run: sleep 10

      - name: Log in to GHCR (pull)
        uses: docker/login-action@c94ce9fb468520275223c153574b00df6fe4bcc9 # v3.7.0
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull and run published image (latest)
        id: grype-scan-published
        uses: ./.github/actions/run-grype-me-container
        with:
          image-ref: ghcr.io/${{ github.repository }}:latest
          pull: 'true'
          scan: head
          output-file: grype-results-published.json
          variable-prefix: GRYPE_PUBLISHED_
          fail-build: 'false'
          severity-cutoff: medium
          only-fixed: 'false'
          db-update: 'false'
          debug: 'false'
          outputs-file: github_output_published.txt

      - name: Verify outputs
        run: |
          echo "=== Published Image Test Results ==="
          echo "Grype Version: ${{ steps.grype-scan-published.outputs.grype-version }}"
          echo "Database Version: ${{ steps.grype-scan-published.outputs.db-version }}"
          echo "Total CVEs: ${{ steps.grype-scan-published.outputs.cve-count }}"

          if [ -z "${{ steps.grype-scan-published.outputs.grype-version }}" ]; then
            echo "ERROR: Grype version output is empty (published image)" >&2
            exit 1
          fi

          if [ ! -f grype-results-published.json ]; then
            echo "ERROR: Output file grype-results-published.json not found" >&2
            exit 1
          fi

          echo "âœ“ Published image (latest) works correctly"
